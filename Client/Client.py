__author__ = 'Daniel Roth'
import zmq

import threading
from thread import allocate_lock
import datetime
import time
import sys

import httplib

from poster.encode import multipart_encode
from poster.streaminghttp import register_openers
import urllib2

from subprocess import call

#GLOBALS
lock = allocate_lock()

class Client():
    port = "8080"
    ip = "localhost"

    def __init__(self, progress):
        self.progress = progress

    def setPort(self, port):
        self.port = port

    def setIp(self, ip):
        self.ip = ip


    #################################
    #           SOCKETS             #
    #################################

    #This function sends a Message to a REP Socket
    def sendAsync(self, flow, size, delay):
        '''
        Loops "flow"-times and sends messages to a ZMQ_Rep socket on a defined Server
        This is threadsave for multiple client instances.
        @param flow:
        @param size:
        @param delay:
        @return:
        '''
        #Connecting the Socket
        context = zmq.Context()
        reqsocket = context.socket(zmq.REQ)
        reqsocket.connect("tcp://" + self.ip + ":" + self.port)
        #send requests
        for i in range(flow):
            time.sleep(delay)
            reqsocket.send('')
            message = reqsocket.recv()
            self.progress.update_progress()
        print "Done! Closing sockets."
        reqsocket.send("EOM")

    #This function sends a Message to a REP Socket
    def sendAsync_time(self, endurance, size, delay):
        '''
        Loops "flow"-times and sends messages to a ZMQ_Rep socket on a defined Server
        This is threadsave for multiple client instances.
        @param flow:
        @param size:
        @param delay:
        @return:
        '''
        #Connecting the Socket
        context = zmq.Context()
        reqsocket = context.socket(zmq.REQ)
        reqsocket.connect("tcp://" + self.ip + ":" + self.port)
        #send requests
        stop = time.time() + endurance
        while time.time() < stop:
            time.sleep(delay)
            reqsocket.send('')
            message = reqsocket.recv()
            #self.progress.update_progress()
        print "\n Done! Closing sockets."
        reqsocket.send("EOM")



    #################################
    #           HTTP                #
    #################################

    def send_http_post(self, ip, httpport, flow, delay, size):
        '''
        Loops "flow"-times and sends a file previously generated by a C Script
        to a webserver via HTTP-POST.
        This is threadsave for multiple client instances.
        @param ip:
        @param httpport:
        @param flow:
        @param delay:
        @return: True / False (Success / Fail)
        '''
        # Register the streaming http handlers with urllib2
        register_openers()
        process = call(["./filemaker/filemaker", size])
        # Run Filemaker (a c program for filemaking by size)
        # A file with the given size(byte) will be stored in /tmp/size
        # headers contains the necessary Content-Type and Content-Length
        # datagen is a generator object that yields the encoded parameters
        datagen, headers = multipart_encode({"file": open("/tmp/size", "rb")})
        conn = httplib.HTTPConnection(ip + ":" + httpport)
        for i in range(flow):
            time.sleep(delay)
            request = urllib2.Request("http://" + ip + ":" + httpport + "/http_post", datagen, headers)
            #lock.acquire()
            if urllib2.urlopen(request).code is not 200:
                print "Something went wrong! Maybe the Server is not running?"
                return False
            self.progress.update_progress()
            #lock.release()
        return True

    def send_http_post_time(self, ip, httpport, endurance, delay, size):
        '''
        Loops "flow"-times and sends a file previously generated by a C Script
        to a webserver via HTTP-POST.
        This is threadsave for multiple client instances.
        @param ip:
        @param httpport:
        @param endurance:
        @param delay:
        @return: True / False (Success / Fail)
        '''
        # Register the streaming http handlers with urllib2
        register_openers()
        process = call(["./filemaker/filemaker", size])
        # Run Filemaker (a c program for filemaking by size)
        # A file with the given size(byte) will be stored in /tmp/size
        # headers contains the necessary Content-Type and Content-Length
        # datagen is a generator object that yields the encoded parameters
        datagen, headers = multipart_encode({"file": open("/tmp/size", "rb")})
        conn = httplib.HTTPConnection(ip + ":" + httpport)
        stop = time.time() + endurance
        while time.time() < stop:
            time.sleep(delay)
            request = urllib2.Request("http://" + ip + ":" + httpport + "/http_post", datagen, headers)
            #lock.acquire()
            if urllib2.urlopen(request).code is not 200:
                print "Something went wrong! Maybe the Server is not running?"
                return False
            #self.progress.update_progress()
            #lock.release()
        return True